{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { defer, of } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS'); // tslint:disable:no-bitwise\n\nclass JwtHelperService {\n  constructor(config = null) {\n    this.tokenGetter = config && config.tokenGetter || function () {};\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n    switch (output.length % 4) {\n      case 0:\n        {\n          break;\n        }\n\n      case 2:\n        {\n          output += '==';\n          break;\n        }\n\n      case 3:\n        {\n          output += '=';\n          break;\n        }\n\n      default:\n        {\n          throw new Error('Illegal base64url string!');\n        }\n    }\n\n    return this.b64DecodeUnicode(output);\n  } // credits for decoder goes to https://github.com/atk\n\n\n  b64decode(str) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let output = '';\n    str = String(str).replace(/=+$/, '');\n\n    if (str.length % 4 === 1) {\n      throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n    }\n\n    for ( // initialize result and counters\n    let bc = 0, bs, buffer, idx = 0; // get next character\n    buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n    // convert the first 8 bits to one ascii character\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n\n    return output;\n  }\n\n  b64DecodeUnicode(str) {\n    return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n  }\n\n  decodeToken(token = this.tokenGetter()) {\n    if (token instanceof Promise) {\n      return token.then(t => this._decodeToken(t));\n    }\n\n    return this._decodeToken(token);\n  }\n\n  _decodeToken(token) {\n    if (!token || token === '') {\n      return null;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== 3) {\n      throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n    }\n\n    const decoded = this.urlBase64Decode(parts[1]);\n\n    if (!decoded) {\n      throw new Error('Cannot decode the token.');\n    }\n\n    return JSON.parse(decoded);\n  }\n\n  getTokenExpirationDate(token = this.tokenGetter()) {\n    if (token instanceof Promise) {\n      return token.then(t => this._getTokenExpirationDate(t));\n    }\n\n    return this._getTokenExpirationDate(token);\n  }\n\n  _getTokenExpirationDate(token) {\n    let decoded;\n    decoded = this.decodeToken(token);\n\n    if (!decoded || !decoded.hasOwnProperty('exp')) {\n      return null;\n    }\n\n    const date = new Date(0);\n    date.setUTCSeconds(decoded.exp);\n    return date;\n  }\n\n  isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n    if (token instanceof Promise) {\n      return token.then(t => this._isTokenExpired(t, offsetSeconds));\n    }\n\n    return this._isTokenExpired(token, offsetSeconds);\n  }\n\n  _isTokenExpired(token, offsetSeconds) {\n    if (!token || token === '') {\n      return true;\n    }\n\n    const date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (date === null) {\n      return false;\n    }\n\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n\n  getAuthScheme(authScheme, request) {\n    if (typeof authScheme === 'function') {\n      return authScheme(request);\n    }\n\n    return authScheme;\n  }\n\n}\n\nJwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n  return new (t || JwtHelperService)(i0.ɵɵinject(JWT_OPTIONS));\n};\n\nJwtHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtHelperService,\n  factory: JwtHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nconst fromPromiseOrValue = input => {\n  if (input instanceof Promise) {\n    return defer(() => input);\n  }\n\n  return of(input);\n};\n\nclass JwtInterceptor {\n  constructor(config, jwtHelper, document) {\n    this.jwtHelper = jwtHelper;\n    this.document = document;\n    this.standardPorts = ['80', '443'];\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || 'Authorization';\n    this.authScheme = config.authScheme || config.authScheme === '' ? config.authScheme : 'Bearer ';\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  isAllowedDomain(request) {\n    const requestUrl = new URL(request.url, this.document.location.origin); // If the host equals the current window origin,\n    // the domain is allowed by default\n\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    } // If not the current domain, check the allowed list\n\n\n    const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? ':' + requestUrl.port : ''}`;\n    return this.allowedDomains.findIndex(domain => typeof domain === 'string' ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n  }\n\n  isDisallowedRoute(request) {\n    const requestedUrl = new URL(request.url, this.document.location.origin);\n    return this.disallowedRoutes.findIndex(route => {\n      if (typeof route === 'string') {\n        const parsedRoute = new URL(route, this.document.location.origin);\n        return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n      }\n\n      if (route instanceof RegExp) {\n        return route.test(request.url);\n      }\n\n      return false;\n    }) > -1;\n  }\n\n  handleInterception(token, request, next) {\n    const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n\n    if (!token && this.throwNoTokenError) {\n      throw new Error('Could not get token from tokenGetter function.');\n    }\n\n    let tokenIsExpired = of(false);\n\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? fromPromiseOrValue(this.jwtHelper.isTokenExpired(token)) : of(true);\n    }\n\n    if (token) {\n      return tokenIsExpired.pipe(map(isExpired => isExpired && this.skipWhenExpired ? request.clone() : request.clone({\n        setHeaders: {\n          [this.headerName]: `${authScheme}${token}`\n        }\n      })), mergeMap(innerRequest => next.handle(innerRequest)));\n    }\n\n    return next.handle(request);\n  }\n\n  intercept(request, next) {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n\n    const token = this.tokenGetter(request);\n    return fromPromiseOrValue(token).pipe(mergeMap(asyncToken => {\n      return this.handleInterception(asyncToken, request, next);\n    }));\n  }\n\n}\n\nJwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n  return new (t || JwtInterceptor)(i0.ɵɵinject(JWT_OPTIONS), i0.ɵɵinject(JwtHelperService), i0.ɵɵinject(DOCUMENT));\n};\n\nJwtInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtInterceptor,\n  factory: JwtInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }, {\n      type: JwtHelperService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwtModule {\n  constructor(parentModule) {\n    if (parentModule) {\n      throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n    }\n  }\n\n  static forRoot(options) {\n    return {\n      ngModule: JwtModule,\n      providers: [{\n        provide: HTTP_INTERCEPTORS,\n        useClass: JwtInterceptor,\n        multi: true\n      }, options.jwtOptionsProvider || {\n        provide: JWT_OPTIONS,\n        useValue: options.config\n      }, JwtHelperService]\n    };\n  }\n\n}\n\nJwtModule.ɵfac = function JwtModule_Factory(t) {\n  return new (t || JwtModule)(i0.ɵɵinject(JwtModule, 12));\n};\n\nJwtModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: JwtModule\n});\nJwtModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: JwtModule,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }];\n  }, null);\n})();\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };","map":{"version":3,"names":["i0","InjectionToken","Injectable","Inject","NgModule","Optional","SkipSelf","DOCUMENT","map","mergeMap","defer","of","HTTP_INTERCEPTORS","JWT_OPTIONS","JwtHelperService","constructor","config","tokenGetter","urlBase64Decode","str","output","replace","length","Error","b64DecodeUnicode","b64decode","chars","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","decodeURIComponent","Array","prototype","call","c","charCodeAt","toString","slice","join","decodeToken","token","Promise","then","t","_decodeToken","parts","split","decoded","JSON","parse","getTokenExpirationDate","_getTokenExpirationDate","hasOwnProperty","date","Date","setUTCSeconds","exp","isTokenExpired","offsetSeconds","_isTokenExpired","valueOf","getAuthScheme","authScheme","request","ɵfac","ɵprov","type","undefined","decorators","args","fromPromiseOrValue","input","JwtInterceptor","jwtHelper","document","standardPorts","headerName","allowedDomains","disallowedRoutes","throwNoTokenError","skipWhenExpired","isAllowedDomain","requestUrl","URL","url","location","origin","host","hostName","hostname","port","includes","findIndex","domain","RegExp","test","isDisallowedRoute","requestedUrl","route","parsedRoute","pathname","handleInterception","next","tokenIsExpired","pipe","isExpired","clone","setHeaders","innerRequest","handle","intercept","asyncToken","Document","JwtModule","parentModule","forRoot","options","ngModule","providers","provide","useClass","multi","jwtOptionsProvider","useValue","ɵmod","ɵinj"],"sources":["C:/Users/samue/Documents/fullstackC/requerimento-app/node_modules/@auth0/angular-jwt/fesm2015/auth0-angular-jwt.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { defer, of } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nclass JwtHelperService {\n    constructor(config = null) {\n        this.tokenGetter = (config && config.tokenGetter) || function () { };\n    }\n    urlBase64Decode(str) {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += '==';\n                break;\n            }\n            case 3: {\n                output += '=';\n                break;\n            }\n            default: {\n                throw new Error('Illegal base64url string!');\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        let output = '';\n        str = String(str).replace(/=+$/, '');\n        if (str.length % 4 === 1) {\n            throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n        }\n        for (\n        // initialize result and counters\n        let bc = 0, bs, buffer, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    }\n    b64DecodeUnicode(str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), (c) => {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(''));\n    }\n    decodeToken(token = this.tokenGetter()) {\n        if (token instanceof Promise) {\n            return token.then(t => this._decodeToken(t));\n        }\n        return this._decodeToken(token);\n    }\n    _decodeToken(token) {\n        if (!token || token === '') {\n            return null;\n        }\n        const parts = token.split('.');\n        if (parts.length !== 3) {\n            throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n        }\n        const decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error('Cannot decode the token.');\n        }\n        return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n        if (token instanceof Promise) {\n            return token.then(t => this._getTokenExpirationDate(t));\n        }\n        return this._getTokenExpirationDate(token);\n    }\n    _getTokenExpirationDate(token) {\n        let decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty('exp')) {\n            return null;\n        }\n        const date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n        if (token instanceof Promise) {\n            return token.then(t => this._isTokenExpired(t, offsetSeconds));\n        }\n        return this._isTokenExpired(token, offsetSeconds);\n    }\n    _isTokenExpired(token, offsetSeconds) {\n        if (!token || token === '') {\n            return true;\n        }\n        const date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n        if (typeof authScheme === 'function') {\n            return authScheme(request);\n        }\n        return authScheme;\n    }\n}\nJwtHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtHelperService, deps: [{ token: JWT_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });\nJwtHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtHelperService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtHelperService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [JWT_OPTIONS]\n                }] }]; } });\n\nconst fromPromiseOrValue = (input) => {\n    if (input instanceof Promise) {\n        return defer(() => input);\n    }\n    return of(input);\n};\nclass JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n        this.jwtHelper = jwtHelper;\n        this.document = document;\n        this.standardPorts = ['80', '443'];\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || 'Authorization';\n        this.authScheme =\n            config.authScheme || config.authScheme === ''\n                ? config.authScheme\n                : 'Bearer ';\n        this.allowedDomains = config.allowedDomains || [];\n        this.disallowedRoutes = config.disallowedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n        const requestUrl = new URL(request.url, this.document.location.origin);\n        // If the host equals the current window origin,\n        // the domain is allowed by default\n        if (requestUrl.host === this.document.location.host) {\n            return true;\n        }\n        // If not the current domain, check the allowed list\n        const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n            ? ':' + requestUrl.port\n            : ''}`;\n        return (this.allowedDomains.findIndex((domain) => typeof domain === 'string'\n            ? domain === hostName\n            : domain instanceof RegExp\n                ? domain.test(hostName)\n                : false) > -1);\n    }\n    isDisallowedRoute(request) {\n        const requestedUrl = new URL(request.url, this.document.location.origin);\n        return (this.disallowedRoutes.findIndex((route) => {\n            if (typeof route === 'string') {\n                const parsedRoute = new URL(route, this.document.location.origin);\n                return (parsedRoute.hostname === requestedUrl.hostname &&\n                    parsedRoute.pathname === requestedUrl.pathname);\n            }\n            if (route instanceof RegExp) {\n                return route.test(request.url);\n            }\n            return false;\n        }) > -1);\n    }\n    handleInterception(token, request, next) {\n        const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n        if (!token && this.throwNoTokenError) {\n            throw new Error('Could not get token from tokenGetter function.');\n        }\n        let tokenIsExpired = of(false);\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? fromPromiseOrValue(this.jwtHelper.isTokenExpired(token)) : of(true);\n        }\n        if (token) {\n            return tokenIsExpired.pipe(map((isExpired) => isExpired && this.skipWhenExpired\n                ? request.clone()\n                : request.clone({\n                    setHeaders: {\n                        [this.headerName]: `${authScheme}${token}`,\n                    },\n                })), mergeMap((innerRequest) => next.handle(innerRequest)));\n        }\n        return next.handle(request);\n    }\n    intercept(request, next) {\n        if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n            return next.handle(request);\n        }\n        const token = this.tokenGetter(request);\n        return fromPromiseOrValue(token).pipe(mergeMap((asyncToken) => {\n            return this.handleInterception(asyncToken, request, next);\n        }));\n    }\n}\nJwtInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtInterceptor, deps: [{ token: JWT_OPTIONS }, { token: JwtHelperService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\nJwtInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [JWT_OPTIONS]\n                }] }, { type: JwtHelperService }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; } });\n\nclass JwtModule {\n    constructor(parentModule) {\n        if (parentModule) {\n            throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n        }\n    }\n    static forRoot(options) {\n        return {\n            ngModule: JwtModule,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true,\n                },\n                options.jwtOptionsProvider || {\n                    provide: JWT_OPTIONS,\n                    useValue: options.config,\n                },\n                JwtHelperService,\n            ],\n        };\n    }\n}\nJwtModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule, deps: [{ token: JwtModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });\nJwtModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule });\nJwtModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: JwtModule, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }]; } });\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}